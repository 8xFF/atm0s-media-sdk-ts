// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.174.0
//   protoc               v4.25.1
// source: cluster_gateway.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import { ConnectRequest, ConnectResponse } from "./gateway";

export const protobufPackage = "cluster_gateway";

export interface GatewayEvent {
  ping?: PingEvent | undefined;
}

export interface PingEvent {
  media?: PingEvent_MediaOrigin | undefined;
  gateway?: PingEvent_GatewayOrigin | undefined;
  cpu: number;
  memory: number;
  disk: number;
  webrtc: PingEvent_ServiceStats | undefined;
}

export interface PingEvent_MediaOrigin {
}

export interface PingEvent_GatewayOrigin {
  zone: number;
  location: PingEvent_GatewayOrigin_Location | undefined;
}

export interface PingEvent_GatewayOrigin_Location {
  lat: number;
  lon: number;
}

export interface PingEvent_ServiceStats {
  live: number;
  max: number;
  active: boolean;
}

export interface Empty {
}

/** For whip */
export interface WhipConnectRequest {
  userAgent: string;
  ip: string;
  sdp: string;
  room: string;
  peer: string;
}

export interface WhipConnectResponse {
  conn: string;
  sdp: string;
}

export interface WhipRemoteIceRequest {
  conn: string;
  ice: string;
}

export interface WhipRemoteIceResponse {
  conn: string;
}

export interface WhipCloseRequest {
  conn: string;
}

export interface WhipCloseResponse {
  conn: string;
}

/** For whep */
export interface WhepConnectRequest {
  userAgent: string;
  ip: string;
  sdp: string;
  room: string;
  peer: string;
}

export interface WhepConnectResponse {
  conn: string;
  sdp: string;
}

export interface WhepRemoteIceRequest {
  conn: string;
  ice: string;
}

export interface WhepRemoteIceResponse {
  conn: string;
}

export interface WhepCloseRequest {
  conn: string;
}

export interface WhepCloseResponse {
  conn: string;
}

/** For SDK */
export interface WebrtcConnectRequest {
  userAgent: string;
  ip: string;
  req: ConnectRequest | undefined;
}

export interface WebrtcConnectResponse {
  res: ConnectResponse | undefined;
}

export interface WebrtcRemoteIceRequest {
  conn: string;
  candidates: string[];
}

export interface WebrtcRemoteIceResponse {
  added: number;
}

export interface WebrtcRestartIceRequest {
  conn: string;
  userAgent: string;
  ip: string;
  req: ConnectRequest | undefined;
}

export interface WebrtcRestartIceResponse {
  res: ConnectResponse | undefined;
}

function createBaseGatewayEvent(): GatewayEvent {
  return { ping: undefined };
}

export const GatewayEvent = {
  encode(message: GatewayEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ping !== undefined) {
      PingEvent.encode(message.ping, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GatewayEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGatewayEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ping = PingEvent.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GatewayEvent {
    return { ping: isSet(object.ping) ? PingEvent.fromJSON(object.ping) : undefined };
  },

  toJSON(message: GatewayEvent): unknown {
    const obj: any = {};
    if (message.ping !== undefined) {
      obj.ping = PingEvent.toJSON(message.ping);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GatewayEvent>, I>>(base?: I): GatewayEvent {
    return GatewayEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GatewayEvent>, I>>(object: I): GatewayEvent {
    const message = createBaseGatewayEvent();
    message.ping = (object.ping !== undefined && object.ping !== null) ? PingEvent.fromPartial(object.ping) : undefined;
    return message;
  },
};

function createBasePingEvent(): PingEvent {
  return { media: undefined, gateway: undefined, cpu: 0, memory: 0, disk: 0, webrtc: undefined };
}

export const PingEvent = {
  encode(message: PingEvent, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.media !== undefined) {
      PingEvent_MediaOrigin.encode(message.media, writer.uint32(10).fork()).ldelim();
    }
    if (message.gateway !== undefined) {
      PingEvent_GatewayOrigin.encode(message.gateway, writer.uint32(18).fork()).ldelim();
    }
    if (message.cpu !== 0) {
      writer.uint32(24).uint32(message.cpu);
    }
    if (message.memory !== 0) {
      writer.uint32(32).uint32(message.memory);
    }
    if (message.disk !== 0) {
      writer.uint32(40).uint32(message.disk);
    }
    if (message.webrtc !== undefined) {
      PingEvent_ServiceStats.encode(message.webrtc, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PingEvent {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.media = PingEvent_MediaOrigin.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.gateway = PingEvent_GatewayOrigin.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.cpu = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.memory = reader.uint32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.disk = reader.uint32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.webrtc = PingEvent_ServiceStats.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PingEvent {
    return {
      media: isSet(object.media) ? PingEvent_MediaOrigin.fromJSON(object.media) : undefined,
      gateway: isSet(object.gateway) ? PingEvent_GatewayOrigin.fromJSON(object.gateway) : undefined,
      cpu: isSet(object.cpu) ? globalThis.Number(object.cpu) : 0,
      memory: isSet(object.memory) ? globalThis.Number(object.memory) : 0,
      disk: isSet(object.disk) ? globalThis.Number(object.disk) : 0,
      webrtc: isSet(object.webrtc) ? PingEvent_ServiceStats.fromJSON(object.webrtc) : undefined,
    };
  },

  toJSON(message: PingEvent): unknown {
    const obj: any = {};
    if (message.media !== undefined) {
      obj.media = PingEvent_MediaOrigin.toJSON(message.media);
    }
    if (message.gateway !== undefined) {
      obj.gateway = PingEvent_GatewayOrigin.toJSON(message.gateway);
    }
    if (message.cpu !== 0) {
      obj.cpu = Math.round(message.cpu);
    }
    if (message.memory !== 0) {
      obj.memory = Math.round(message.memory);
    }
    if (message.disk !== 0) {
      obj.disk = Math.round(message.disk);
    }
    if (message.webrtc !== undefined) {
      obj.webrtc = PingEvent_ServiceStats.toJSON(message.webrtc);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PingEvent>, I>>(base?: I): PingEvent {
    return PingEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PingEvent>, I>>(object: I): PingEvent {
    const message = createBasePingEvent();
    message.media = (object.media !== undefined && object.media !== null)
      ? PingEvent_MediaOrigin.fromPartial(object.media)
      : undefined;
    message.gateway = (object.gateway !== undefined && object.gateway !== null)
      ? PingEvent_GatewayOrigin.fromPartial(object.gateway)
      : undefined;
    message.cpu = object.cpu ?? 0;
    message.memory = object.memory ?? 0;
    message.disk = object.disk ?? 0;
    message.webrtc = (object.webrtc !== undefined && object.webrtc !== null)
      ? PingEvent_ServiceStats.fromPartial(object.webrtc)
      : undefined;
    return message;
  },
};

function createBasePingEvent_MediaOrigin(): PingEvent_MediaOrigin {
  return {};
}

export const PingEvent_MediaOrigin = {
  encode(_: PingEvent_MediaOrigin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PingEvent_MediaOrigin {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingEvent_MediaOrigin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PingEvent_MediaOrigin {
    return {};
  },

  toJSON(_: PingEvent_MediaOrigin): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PingEvent_MediaOrigin>, I>>(base?: I): PingEvent_MediaOrigin {
    return PingEvent_MediaOrigin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PingEvent_MediaOrigin>, I>>(_: I): PingEvent_MediaOrigin {
    const message = createBasePingEvent_MediaOrigin();
    return message;
  },
};

function createBasePingEvent_GatewayOrigin(): PingEvent_GatewayOrigin {
  return { zone: 0, location: undefined };
}

export const PingEvent_GatewayOrigin = {
  encode(message: PingEvent_GatewayOrigin, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.zone !== 0) {
      writer.uint32(8).uint32(message.zone);
    }
    if (message.location !== undefined) {
      PingEvent_GatewayOrigin_Location.encode(message.location, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PingEvent_GatewayOrigin {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingEvent_GatewayOrigin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.zone = reader.uint32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.location = PingEvent_GatewayOrigin_Location.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PingEvent_GatewayOrigin {
    return {
      zone: isSet(object.zone) ? globalThis.Number(object.zone) : 0,
      location: isSet(object.location) ? PingEvent_GatewayOrigin_Location.fromJSON(object.location) : undefined,
    };
  },

  toJSON(message: PingEvent_GatewayOrigin): unknown {
    const obj: any = {};
    if (message.zone !== 0) {
      obj.zone = Math.round(message.zone);
    }
    if (message.location !== undefined) {
      obj.location = PingEvent_GatewayOrigin_Location.toJSON(message.location);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PingEvent_GatewayOrigin>, I>>(base?: I): PingEvent_GatewayOrigin {
    return PingEvent_GatewayOrigin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PingEvent_GatewayOrigin>, I>>(object: I): PingEvent_GatewayOrigin {
    const message = createBasePingEvent_GatewayOrigin();
    message.zone = object.zone ?? 0;
    message.location = (object.location !== undefined && object.location !== null)
      ? PingEvent_GatewayOrigin_Location.fromPartial(object.location)
      : undefined;
    return message;
  },
};

function createBasePingEvent_GatewayOrigin_Location(): PingEvent_GatewayOrigin_Location {
  return { lat: 0, lon: 0 };
}

export const PingEvent_GatewayOrigin_Location = {
  encode(message: PingEvent_GatewayOrigin_Location, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.lat !== 0) {
      writer.uint32(13).float(message.lat);
    }
    if (message.lon !== 0) {
      writer.uint32(21).float(message.lon);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PingEvent_GatewayOrigin_Location {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingEvent_GatewayOrigin_Location();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.lat = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.lon = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PingEvent_GatewayOrigin_Location {
    return {
      lat: isSet(object.lat) ? globalThis.Number(object.lat) : 0,
      lon: isSet(object.lon) ? globalThis.Number(object.lon) : 0,
    };
  },

  toJSON(message: PingEvent_GatewayOrigin_Location): unknown {
    const obj: any = {};
    if (message.lat !== 0) {
      obj.lat = message.lat;
    }
    if (message.lon !== 0) {
      obj.lon = message.lon;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PingEvent_GatewayOrigin_Location>, I>>(
    base?: I,
  ): PingEvent_GatewayOrigin_Location {
    return PingEvent_GatewayOrigin_Location.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PingEvent_GatewayOrigin_Location>, I>>(
    object: I,
  ): PingEvent_GatewayOrigin_Location {
    const message = createBasePingEvent_GatewayOrigin_Location();
    message.lat = object.lat ?? 0;
    message.lon = object.lon ?? 0;
    return message;
  },
};

function createBasePingEvent_ServiceStats(): PingEvent_ServiceStats {
  return { live: 0, max: 0, active: false };
}

export const PingEvent_ServiceStats = {
  encode(message: PingEvent_ServiceStats, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.live !== 0) {
      writer.uint32(8).uint32(message.live);
    }
    if (message.max !== 0) {
      writer.uint32(16).uint32(message.max);
    }
    if (message.active !== false) {
      writer.uint32(24).bool(message.active);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PingEvent_ServiceStats {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingEvent_ServiceStats();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.live = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.max = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.active = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PingEvent_ServiceStats {
    return {
      live: isSet(object.live) ? globalThis.Number(object.live) : 0,
      max: isSet(object.max) ? globalThis.Number(object.max) : 0,
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
    };
  },

  toJSON(message: PingEvent_ServiceStats): unknown {
    const obj: any = {};
    if (message.live !== 0) {
      obj.live = Math.round(message.live);
    }
    if (message.max !== 0) {
      obj.max = Math.round(message.max);
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PingEvent_ServiceStats>, I>>(base?: I): PingEvent_ServiceStats {
    return PingEvent_ServiceStats.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PingEvent_ServiceStats>, I>>(object: I): PingEvent_ServiceStats {
    const message = createBasePingEvent_ServiceStats();
    message.live = object.live ?? 0;
    message.max = object.max ?? 0;
    message.active = object.active ?? false;
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty = {
  encode(_: Empty, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Empty {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseWhipConnectRequest(): WhipConnectRequest {
  return { userAgent: "", ip: "", sdp: "", room: "", peer: "" };
}

export const WhipConnectRequest = {
  encode(message: WhipConnectRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userAgent !== "") {
      writer.uint32(10).string(message.userAgent);
    }
    if (message.ip !== "") {
      writer.uint32(18).string(message.ip);
    }
    if (message.sdp !== "") {
      writer.uint32(26).string(message.sdp);
    }
    if (message.room !== "") {
      writer.uint32(34).string(message.room);
    }
    if (message.peer !== "") {
      writer.uint32(42).string(message.peer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhipConnectRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhipConnectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ip = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sdp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.room = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.peer = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhipConnectRequest {
    return {
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      sdp: isSet(object.sdp) ? globalThis.String(object.sdp) : "",
      room: isSet(object.room) ? globalThis.String(object.room) : "",
      peer: isSet(object.peer) ? globalThis.String(object.peer) : "",
    };
  },

  toJSON(message: WhipConnectRequest): unknown {
    const obj: any = {};
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.sdp !== "") {
      obj.sdp = message.sdp;
    }
    if (message.room !== "") {
      obj.room = message.room;
    }
    if (message.peer !== "") {
      obj.peer = message.peer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhipConnectRequest>, I>>(base?: I): WhipConnectRequest {
    return WhipConnectRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhipConnectRequest>, I>>(object: I): WhipConnectRequest {
    const message = createBaseWhipConnectRequest();
    message.userAgent = object.userAgent ?? "";
    message.ip = object.ip ?? "";
    message.sdp = object.sdp ?? "";
    message.room = object.room ?? "";
    message.peer = object.peer ?? "";
    return message;
  },
};

function createBaseWhipConnectResponse(): WhipConnectResponse {
  return { conn: "", sdp: "" };
}

export const WhipConnectResponse = {
  encode(message: WhipConnectResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conn !== "") {
      writer.uint32(10).string(message.conn);
    }
    if (message.sdp !== "") {
      writer.uint32(18).string(message.sdp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhipConnectResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhipConnectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conn = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sdp = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhipConnectResponse {
    return {
      conn: isSet(object.conn) ? globalThis.String(object.conn) : "",
      sdp: isSet(object.sdp) ? globalThis.String(object.sdp) : "",
    };
  },

  toJSON(message: WhipConnectResponse): unknown {
    const obj: any = {};
    if (message.conn !== "") {
      obj.conn = message.conn;
    }
    if (message.sdp !== "") {
      obj.sdp = message.sdp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhipConnectResponse>, I>>(base?: I): WhipConnectResponse {
    return WhipConnectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhipConnectResponse>, I>>(object: I): WhipConnectResponse {
    const message = createBaseWhipConnectResponse();
    message.conn = object.conn ?? "";
    message.sdp = object.sdp ?? "";
    return message;
  },
};

function createBaseWhipRemoteIceRequest(): WhipRemoteIceRequest {
  return { conn: "", ice: "" };
}

export const WhipRemoteIceRequest = {
  encode(message: WhipRemoteIceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conn !== "") {
      writer.uint32(10).string(message.conn);
    }
    if (message.ice !== "") {
      writer.uint32(18).string(message.ice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhipRemoteIceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhipRemoteIceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conn = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ice = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhipRemoteIceRequest {
    return {
      conn: isSet(object.conn) ? globalThis.String(object.conn) : "",
      ice: isSet(object.ice) ? globalThis.String(object.ice) : "",
    };
  },

  toJSON(message: WhipRemoteIceRequest): unknown {
    const obj: any = {};
    if (message.conn !== "") {
      obj.conn = message.conn;
    }
    if (message.ice !== "") {
      obj.ice = message.ice;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhipRemoteIceRequest>, I>>(base?: I): WhipRemoteIceRequest {
    return WhipRemoteIceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhipRemoteIceRequest>, I>>(object: I): WhipRemoteIceRequest {
    const message = createBaseWhipRemoteIceRequest();
    message.conn = object.conn ?? "";
    message.ice = object.ice ?? "";
    return message;
  },
};

function createBaseWhipRemoteIceResponse(): WhipRemoteIceResponse {
  return { conn: "" };
}

export const WhipRemoteIceResponse = {
  encode(message: WhipRemoteIceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conn !== "") {
      writer.uint32(10).string(message.conn);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhipRemoteIceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhipRemoteIceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conn = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhipRemoteIceResponse {
    return { conn: isSet(object.conn) ? globalThis.String(object.conn) : "" };
  },

  toJSON(message: WhipRemoteIceResponse): unknown {
    const obj: any = {};
    if (message.conn !== "") {
      obj.conn = message.conn;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhipRemoteIceResponse>, I>>(base?: I): WhipRemoteIceResponse {
    return WhipRemoteIceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhipRemoteIceResponse>, I>>(object: I): WhipRemoteIceResponse {
    const message = createBaseWhipRemoteIceResponse();
    message.conn = object.conn ?? "";
    return message;
  },
};

function createBaseWhipCloseRequest(): WhipCloseRequest {
  return { conn: "" };
}

export const WhipCloseRequest = {
  encode(message: WhipCloseRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conn !== "") {
      writer.uint32(10).string(message.conn);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhipCloseRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhipCloseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conn = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhipCloseRequest {
    return { conn: isSet(object.conn) ? globalThis.String(object.conn) : "" };
  },

  toJSON(message: WhipCloseRequest): unknown {
    const obj: any = {};
    if (message.conn !== "") {
      obj.conn = message.conn;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhipCloseRequest>, I>>(base?: I): WhipCloseRequest {
    return WhipCloseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhipCloseRequest>, I>>(object: I): WhipCloseRequest {
    const message = createBaseWhipCloseRequest();
    message.conn = object.conn ?? "";
    return message;
  },
};

function createBaseWhipCloseResponse(): WhipCloseResponse {
  return { conn: "" };
}

export const WhipCloseResponse = {
  encode(message: WhipCloseResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conn !== "") {
      writer.uint32(10).string(message.conn);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhipCloseResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhipCloseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conn = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhipCloseResponse {
    return { conn: isSet(object.conn) ? globalThis.String(object.conn) : "" };
  },

  toJSON(message: WhipCloseResponse): unknown {
    const obj: any = {};
    if (message.conn !== "") {
      obj.conn = message.conn;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhipCloseResponse>, I>>(base?: I): WhipCloseResponse {
    return WhipCloseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhipCloseResponse>, I>>(object: I): WhipCloseResponse {
    const message = createBaseWhipCloseResponse();
    message.conn = object.conn ?? "";
    return message;
  },
};

function createBaseWhepConnectRequest(): WhepConnectRequest {
  return { userAgent: "", ip: "", sdp: "", room: "", peer: "" };
}

export const WhepConnectRequest = {
  encode(message: WhepConnectRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userAgent !== "") {
      writer.uint32(10).string(message.userAgent);
    }
    if (message.ip !== "") {
      writer.uint32(18).string(message.ip);
    }
    if (message.sdp !== "") {
      writer.uint32(26).string(message.sdp);
    }
    if (message.room !== "") {
      writer.uint32(34).string(message.room);
    }
    if (message.peer !== "") {
      writer.uint32(42).string(message.peer);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhepConnectRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhepConnectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ip = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.sdp = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.room = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.peer = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhepConnectRequest {
    return {
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      sdp: isSet(object.sdp) ? globalThis.String(object.sdp) : "",
      room: isSet(object.room) ? globalThis.String(object.room) : "",
      peer: isSet(object.peer) ? globalThis.String(object.peer) : "",
    };
  },

  toJSON(message: WhepConnectRequest): unknown {
    const obj: any = {};
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.sdp !== "") {
      obj.sdp = message.sdp;
    }
    if (message.room !== "") {
      obj.room = message.room;
    }
    if (message.peer !== "") {
      obj.peer = message.peer;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhepConnectRequest>, I>>(base?: I): WhepConnectRequest {
    return WhepConnectRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhepConnectRequest>, I>>(object: I): WhepConnectRequest {
    const message = createBaseWhepConnectRequest();
    message.userAgent = object.userAgent ?? "";
    message.ip = object.ip ?? "";
    message.sdp = object.sdp ?? "";
    message.room = object.room ?? "";
    message.peer = object.peer ?? "";
    return message;
  },
};

function createBaseWhepConnectResponse(): WhepConnectResponse {
  return { conn: "", sdp: "" };
}

export const WhepConnectResponse = {
  encode(message: WhepConnectResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conn !== "") {
      writer.uint32(10).string(message.conn);
    }
    if (message.sdp !== "") {
      writer.uint32(18).string(message.sdp);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhepConnectResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhepConnectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conn = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sdp = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhepConnectResponse {
    return {
      conn: isSet(object.conn) ? globalThis.String(object.conn) : "",
      sdp: isSet(object.sdp) ? globalThis.String(object.sdp) : "",
    };
  },

  toJSON(message: WhepConnectResponse): unknown {
    const obj: any = {};
    if (message.conn !== "") {
      obj.conn = message.conn;
    }
    if (message.sdp !== "") {
      obj.sdp = message.sdp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhepConnectResponse>, I>>(base?: I): WhepConnectResponse {
    return WhepConnectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhepConnectResponse>, I>>(object: I): WhepConnectResponse {
    const message = createBaseWhepConnectResponse();
    message.conn = object.conn ?? "";
    message.sdp = object.sdp ?? "";
    return message;
  },
};

function createBaseWhepRemoteIceRequest(): WhepRemoteIceRequest {
  return { conn: "", ice: "" };
}

export const WhepRemoteIceRequest = {
  encode(message: WhepRemoteIceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conn !== "") {
      writer.uint32(10).string(message.conn);
    }
    if (message.ice !== "") {
      writer.uint32(18).string(message.ice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhepRemoteIceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhepRemoteIceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conn = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ice = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhepRemoteIceRequest {
    return {
      conn: isSet(object.conn) ? globalThis.String(object.conn) : "",
      ice: isSet(object.ice) ? globalThis.String(object.ice) : "",
    };
  },

  toJSON(message: WhepRemoteIceRequest): unknown {
    const obj: any = {};
    if (message.conn !== "") {
      obj.conn = message.conn;
    }
    if (message.ice !== "") {
      obj.ice = message.ice;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhepRemoteIceRequest>, I>>(base?: I): WhepRemoteIceRequest {
    return WhepRemoteIceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhepRemoteIceRequest>, I>>(object: I): WhepRemoteIceRequest {
    const message = createBaseWhepRemoteIceRequest();
    message.conn = object.conn ?? "";
    message.ice = object.ice ?? "";
    return message;
  },
};

function createBaseWhepRemoteIceResponse(): WhepRemoteIceResponse {
  return { conn: "" };
}

export const WhepRemoteIceResponse = {
  encode(message: WhepRemoteIceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conn !== "") {
      writer.uint32(10).string(message.conn);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhepRemoteIceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhepRemoteIceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conn = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhepRemoteIceResponse {
    return { conn: isSet(object.conn) ? globalThis.String(object.conn) : "" };
  },

  toJSON(message: WhepRemoteIceResponse): unknown {
    const obj: any = {};
    if (message.conn !== "") {
      obj.conn = message.conn;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhepRemoteIceResponse>, I>>(base?: I): WhepRemoteIceResponse {
    return WhepRemoteIceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhepRemoteIceResponse>, I>>(object: I): WhepRemoteIceResponse {
    const message = createBaseWhepRemoteIceResponse();
    message.conn = object.conn ?? "";
    return message;
  },
};

function createBaseWhepCloseRequest(): WhepCloseRequest {
  return { conn: "" };
}

export const WhepCloseRequest = {
  encode(message: WhepCloseRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conn !== "") {
      writer.uint32(10).string(message.conn);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhepCloseRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhepCloseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conn = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhepCloseRequest {
    return { conn: isSet(object.conn) ? globalThis.String(object.conn) : "" };
  },

  toJSON(message: WhepCloseRequest): unknown {
    const obj: any = {};
    if (message.conn !== "") {
      obj.conn = message.conn;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhepCloseRequest>, I>>(base?: I): WhepCloseRequest {
    return WhepCloseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhepCloseRequest>, I>>(object: I): WhepCloseRequest {
    const message = createBaseWhepCloseRequest();
    message.conn = object.conn ?? "";
    return message;
  },
};

function createBaseWhepCloseResponse(): WhepCloseResponse {
  return { conn: "" };
}

export const WhepCloseResponse = {
  encode(message: WhepCloseResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conn !== "") {
      writer.uint32(10).string(message.conn);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WhepCloseResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWhepCloseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conn = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WhepCloseResponse {
    return { conn: isSet(object.conn) ? globalThis.String(object.conn) : "" };
  },

  toJSON(message: WhepCloseResponse): unknown {
    const obj: any = {};
    if (message.conn !== "") {
      obj.conn = message.conn;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WhepCloseResponse>, I>>(base?: I): WhepCloseResponse {
    return WhepCloseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WhepCloseResponse>, I>>(object: I): WhepCloseResponse {
    const message = createBaseWhepCloseResponse();
    message.conn = object.conn ?? "";
    return message;
  },
};

function createBaseWebrtcConnectRequest(): WebrtcConnectRequest {
  return { userAgent: "", ip: "", req: undefined };
}

export const WebrtcConnectRequest = {
  encode(message: WebrtcConnectRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userAgent !== "") {
      writer.uint32(10).string(message.userAgent);
    }
    if (message.ip !== "") {
      writer.uint32(18).string(message.ip);
    }
    if (message.req !== undefined) {
      ConnectRequest.encode(message.req, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WebrtcConnectRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebrtcConnectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ip = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.req = ConnectRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebrtcConnectRequest {
    return {
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      req: isSet(object.req) ? ConnectRequest.fromJSON(object.req) : undefined,
    };
  },

  toJSON(message: WebrtcConnectRequest): unknown {
    const obj: any = {};
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.req !== undefined) {
      obj.req = ConnectRequest.toJSON(message.req);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebrtcConnectRequest>, I>>(base?: I): WebrtcConnectRequest {
    return WebrtcConnectRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebrtcConnectRequest>, I>>(object: I): WebrtcConnectRequest {
    const message = createBaseWebrtcConnectRequest();
    message.userAgent = object.userAgent ?? "";
    message.ip = object.ip ?? "";
    message.req = (object.req !== undefined && object.req !== null)
      ? ConnectRequest.fromPartial(object.req)
      : undefined;
    return message;
  },
};

function createBaseWebrtcConnectResponse(): WebrtcConnectResponse {
  return { res: undefined };
}

export const WebrtcConnectResponse = {
  encode(message: WebrtcConnectResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.res !== undefined) {
      ConnectResponse.encode(message.res, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WebrtcConnectResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebrtcConnectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.res = ConnectResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebrtcConnectResponse {
    return { res: isSet(object.res) ? ConnectResponse.fromJSON(object.res) : undefined };
  },

  toJSON(message: WebrtcConnectResponse): unknown {
    const obj: any = {};
    if (message.res !== undefined) {
      obj.res = ConnectResponse.toJSON(message.res);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebrtcConnectResponse>, I>>(base?: I): WebrtcConnectResponse {
    return WebrtcConnectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebrtcConnectResponse>, I>>(object: I): WebrtcConnectResponse {
    const message = createBaseWebrtcConnectResponse();
    message.res = (object.res !== undefined && object.res !== null)
      ? ConnectResponse.fromPartial(object.res)
      : undefined;
    return message;
  },
};

function createBaseWebrtcRemoteIceRequest(): WebrtcRemoteIceRequest {
  return { conn: "", candidates: [] };
}

export const WebrtcRemoteIceRequest = {
  encode(message: WebrtcRemoteIceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conn !== "") {
      writer.uint32(10).string(message.conn);
    }
    for (const v of message.candidates) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WebrtcRemoteIceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebrtcRemoteIceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conn = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.candidates.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebrtcRemoteIceRequest {
    return {
      conn: isSet(object.conn) ? globalThis.String(object.conn) : "",
      candidates: globalThis.Array.isArray(object?.candidates)
        ? object.candidates.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: WebrtcRemoteIceRequest): unknown {
    const obj: any = {};
    if (message.conn !== "") {
      obj.conn = message.conn;
    }
    if (message.candidates?.length) {
      obj.candidates = message.candidates;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebrtcRemoteIceRequest>, I>>(base?: I): WebrtcRemoteIceRequest {
    return WebrtcRemoteIceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebrtcRemoteIceRequest>, I>>(object: I): WebrtcRemoteIceRequest {
    const message = createBaseWebrtcRemoteIceRequest();
    message.conn = object.conn ?? "";
    message.candidates = object.candidates?.map((e) => e) || [];
    return message;
  },
};

function createBaseWebrtcRemoteIceResponse(): WebrtcRemoteIceResponse {
  return { added: 0 };
}

export const WebrtcRemoteIceResponse = {
  encode(message: WebrtcRemoteIceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.added !== 0) {
      writer.uint32(8).uint32(message.added);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WebrtcRemoteIceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebrtcRemoteIceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.added = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebrtcRemoteIceResponse {
    return { added: isSet(object.added) ? globalThis.Number(object.added) : 0 };
  },

  toJSON(message: WebrtcRemoteIceResponse): unknown {
    const obj: any = {};
    if (message.added !== 0) {
      obj.added = Math.round(message.added);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebrtcRemoteIceResponse>, I>>(base?: I): WebrtcRemoteIceResponse {
    return WebrtcRemoteIceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebrtcRemoteIceResponse>, I>>(object: I): WebrtcRemoteIceResponse {
    const message = createBaseWebrtcRemoteIceResponse();
    message.added = object.added ?? 0;
    return message;
  },
};

function createBaseWebrtcRestartIceRequest(): WebrtcRestartIceRequest {
  return { conn: "", userAgent: "", ip: "", req: undefined };
}

export const WebrtcRestartIceRequest = {
  encode(message: WebrtcRestartIceRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.conn !== "") {
      writer.uint32(10).string(message.conn);
    }
    if (message.userAgent !== "") {
      writer.uint32(18).string(message.userAgent);
    }
    if (message.ip !== "") {
      writer.uint32(26).string(message.ip);
    }
    if (message.req !== undefined) {
      ConnectRequest.encode(message.req, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WebrtcRestartIceRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebrtcRestartIceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.conn = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.ip = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.req = ConnectRequest.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebrtcRestartIceRequest {
    return {
      conn: isSet(object.conn) ? globalThis.String(object.conn) : "",
      userAgent: isSet(object.userAgent) ? globalThis.String(object.userAgent) : "",
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      req: isSet(object.req) ? ConnectRequest.fromJSON(object.req) : undefined,
    };
  },

  toJSON(message: WebrtcRestartIceRequest): unknown {
    const obj: any = {};
    if (message.conn !== "") {
      obj.conn = message.conn;
    }
    if (message.userAgent !== "") {
      obj.userAgent = message.userAgent;
    }
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.req !== undefined) {
      obj.req = ConnectRequest.toJSON(message.req);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebrtcRestartIceRequest>, I>>(base?: I): WebrtcRestartIceRequest {
    return WebrtcRestartIceRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebrtcRestartIceRequest>, I>>(object: I): WebrtcRestartIceRequest {
    const message = createBaseWebrtcRestartIceRequest();
    message.conn = object.conn ?? "";
    message.userAgent = object.userAgent ?? "";
    message.ip = object.ip ?? "";
    message.req = (object.req !== undefined && object.req !== null)
      ? ConnectRequest.fromPartial(object.req)
      : undefined;
    return message;
  },
};

function createBaseWebrtcRestartIceResponse(): WebrtcRestartIceResponse {
  return { res: undefined };
}

export const WebrtcRestartIceResponse = {
  encode(message: WebrtcRestartIceResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.res !== undefined) {
      ConnectResponse.encode(message.res, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WebrtcRestartIceResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWebrtcRestartIceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.res = ConnectResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WebrtcRestartIceResponse {
    return { res: isSet(object.res) ? ConnectResponse.fromJSON(object.res) : undefined };
  },

  toJSON(message: WebrtcRestartIceResponse): unknown {
    const obj: any = {};
    if (message.res !== undefined) {
      obj.res = ConnectResponse.toJSON(message.res);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WebrtcRestartIceResponse>, I>>(base?: I): WebrtcRestartIceResponse {
    return WebrtcRestartIceResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WebrtcRestartIceResponse>, I>>(object: I): WebrtcRestartIceResponse {
    const message = createBaseWebrtcRestartIceResponse();
    message.res = (object.res !== undefined && object.res !== null)
      ? ConnectResponse.fromPartial(object.res)
      : undefined;
    return message;
  },
};

export interface MediaEdge {
  WhipConnect(request: WhipConnectRequest): Promise<WhipConnectResponse>;
  WhipRemoteIce(request: WhipRemoteIceRequest): Promise<WhipRemoteIceResponse>;
  WhipClose(request: WhipCloseRequest): Promise<WhipCloseResponse>;
  WhepConnect(request: WhepConnectRequest): Promise<WhepConnectResponse>;
  WhepRemoteIce(request: WhepRemoteIceRequest): Promise<WhepRemoteIceResponse>;
  WhepClose(request: WhepCloseRequest): Promise<WhepCloseResponse>;
  WebrtcConnect(request: WebrtcConnectRequest): Promise<WebrtcConnectResponse>;
  WebrtcRemoteIce(request: WebrtcRemoteIceRequest): Promise<WebrtcRemoteIceResponse>;
  WebrtcRestartIce(request: WebrtcRestartIceRequest): Promise<WebrtcRestartIceResponse>;
}

export const MediaEdgeServiceName = "cluster_gateway.MediaEdge";
export class MediaEdgeClientImpl implements MediaEdge {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MediaEdgeServiceName;
    this.rpc = rpc;
    this.WhipConnect = this.WhipConnect.bind(this);
    this.WhipRemoteIce = this.WhipRemoteIce.bind(this);
    this.WhipClose = this.WhipClose.bind(this);
    this.WhepConnect = this.WhepConnect.bind(this);
    this.WhepRemoteIce = this.WhepRemoteIce.bind(this);
    this.WhepClose = this.WhepClose.bind(this);
    this.WebrtcConnect = this.WebrtcConnect.bind(this);
    this.WebrtcRemoteIce = this.WebrtcRemoteIce.bind(this);
    this.WebrtcRestartIce = this.WebrtcRestartIce.bind(this);
  }
  WhipConnect(request: WhipConnectRequest): Promise<WhipConnectResponse> {
    const data = WhipConnectRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "WhipConnect", data);
    return promise.then((data) => WhipConnectResponse.decode(_m0.Reader.create(data)));
  }

  WhipRemoteIce(request: WhipRemoteIceRequest): Promise<WhipRemoteIceResponse> {
    const data = WhipRemoteIceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "WhipRemoteIce", data);
    return promise.then((data) => WhipRemoteIceResponse.decode(_m0.Reader.create(data)));
  }

  WhipClose(request: WhipCloseRequest): Promise<WhipCloseResponse> {
    const data = WhipCloseRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "WhipClose", data);
    return promise.then((data) => WhipCloseResponse.decode(_m0.Reader.create(data)));
  }

  WhepConnect(request: WhepConnectRequest): Promise<WhepConnectResponse> {
    const data = WhepConnectRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "WhepConnect", data);
    return promise.then((data) => WhepConnectResponse.decode(_m0.Reader.create(data)));
  }

  WhepRemoteIce(request: WhepRemoteIceRequest): Promise<WhepRemoteIceResponse> {
    const data = WhepRemoteIceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "WhepRemoteIce", data);
    return promise.then((data) => WhepRemoteIceResponse.decode(_m0.Reader.create(data)));
  }

  WhepClose(request: WhepCloseRequest): Promise<WhepCloseResponse> {
    const data = WhepCloseRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "WhepClose", data);
    return promise.then((data) => WhepCloseResponse.decode(_m0.Reader.create(data)));
  }

  WebrtcConnect(request: WebrtcConnectRequest): Promise<WebrtcConnectResponse> {
    const data = WebrtcConnectRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "WebrtcConnect", data);
    return promise.then((data) => WebrtcConnectResponse.decode(_m0.Reader.create(data)));
  }

  WebrtcRemoteIce(request: WebrtcRemoteIceRequest): Promise<WebrtcRemoteIceResponse> {
    const data = WebrtcRemoteIceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "WebrtcRemoteIce", data);
    return promise.then((data) => WebrtcRemoteIceResponse.decode(_m0.Reader.create(data)));
  }

  WebrtcRestartIce(request: WebrtcRestartIceRequest): Promise<WebrtcRestartIceResponse> {
    const data = WebrtcRestartIceRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "WebrtcRestartIce", data);
    return promise.then((data) => WebrtcRestartIceResponse.decode(_m0.Reader.create(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
